Initial grid implementation with a `List`, accessed by scanning the content. Not bad performances.

Wrapped the features into a `Grid` class, implemented in Wren and using a `List`. This time the perfomances dropped due to the fact that no optimizatons could be done and each cell's access require a new computation of the (linear) list element index.

```
class Grid {

    construct new(width, height) {
        _width = width
        _height = height
        _data = List.filled(width * height, 0)
    }

    fill(value) {
        for (i in 0 ... _width * _height) {
            _data[i] = value
        }
    }

    peek(x, y) {
        return _data[(y * _width) + x]
    }

    poke(x, y, value) {
        _data[(y * _width) + x] = value
    }

}
```

We can optimize this a bit, by saving the multiplications and pre-compute the offsets for each row

```
class Grid {

    construct new(width, height) {
        _width = width
        _height = height
        _data = List.filled(width * height, 0)
        _offsets = List.filled(height, 0)
        for (i in 0 ... _height) {
            _offsets[i] = i * _width
        }
    }

    fill(value) {
        for (i in 0 ... _width * _height) {
            _data[i] = value
        }
    }

    peek(x, y) {
        return _data[_offsets[y] + x]
    }

    poke(x, y, value) {
        _data[_offsets[y] + x] = value
    }

}
```

However, this won't change very much the overall performances.

Up to 100 times slower when filling the list. 70% slower on random access.

This is not due to the (ranged) for loop, but how is implemented the *safe* access to the list content. Each time the index is validated. Also, the native implementation is cache-friendly while accessing data. This is also clear from the `line()` calls, where the native implementation display its cache-easyness while the script implementations are pretty much identical.
